[TOC]

# Java开启线程，怎样保证线程安全

线程和进程的区别：进程是操作系统进行资源分配的最小单元。线程是操作系统进行任务分配的最小单位，线程属于进程。

1. 继承Thread, 重写run方法
2. 实现Runnable，实现run方法
3. 实现Callable接口，实现call方法。通过FutureTask创建一个线程，获取到线程执行的返回值。
4. 通过线程池来开启线程



保证线程安全：

核心思想--加锁： 

1. JVM提供的锁，也就是Synchronized关键字。
2. JDK提供的各种Lock。



# Volatile和Synchronized有什么区别？Volatile能不能保证线程安全？DCL （Double Check Lock）单例为什么要加Volatile?

1. Synchronized关键字，用来加锁。Volatile只是保持变量的线程可见性。通常适用于一个线程写，多个线程读的场景。
2. 不能。Volatile关键字只能保证线程可见性，不能保证原子性。

一般来说如果两个线程共用一个变量，一开始大家都读一份，但是有一个线程修改了变量，此时并不会告知另一个线程变量被修改了，要重新读取一份。给变量加上Volatile后则会将这个变化立马感知，传递给另一个线程，（机制依旧是用主内存做的）。

3. Volatile防止指令重排。（Double Check Lock：在锁的前面后后面都进行一次判断）（指令重排，例如：CPU等待内存返回时可以插入一些程序执行（CPU执行的更快））

（CPU底层执行Integer i= 8，会分成三个步骤：1. 分配内存（初始值0） 2. 对象初始化 3. 建立指针对应关系，指令重排后可能是1-3-2，导致多线程时读取到i=0), 所以Volatile可以保证一定是1-2-3。

在DCL中，防止高并发情况下，指令重排导致的线程安全问题。



# Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？

1. Java的锁就是在对象的Markword中记录一个锁状态。无锁、偏向锁、轻量级锁、重量级锁对应不同的锁的状态。
2. Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。



# 谈谈你对AQS的理解。AQS任何实现可重入锁？

1. AQS是Java线程同步的框架。是JDK中许多锁工具的核心实现框架
2. 在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行。在不同的场景下，有不同的意义。
3. 在可重入锁这个场景下，state就用来表示加锁的次数。0表示无锁，每加一次锁，state就加1.释放锁state就减1。



# 有A，B，C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行 ？

CountDownLatch: 倒数栅栏

CylicBarrier：等车排队

Semaphore：信号，给排队的线程一个权重



# 如何对一个字符串进行快速排序

Fork/Join框架：分而治之的思想（拆分、汇总）





