# 一些修饰符

[TOC]

## 访问修饰符

### protected



protected 需要从以下两个点来分析说明：

- **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
- **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。



关于protected修饰符分享一点自己总结的规律：

遇到调用protected修饰的方法，沿着继承关系向上寻找此方法的最后一次实现是否和当前调用的地方处于同一个包内，如果是，那么可以调用，如果不是，那么不行。但有一种情况例外，如果向上寻找实现的时候路过了当前调用的地方所处的类，那么这种情况下即使本类没有实现这个方法，那也是可以编译通过的。



其实对于protected的理解通俗点讲就是，这个方法，只有你跟我在一起（同一个包）的时候才给你用，你不跟我在一起我就不给你用了。



## 非访问修饰符

为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

static 修饰符，用来修饰类方法和类变量。

final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

abstract 修饰符，用来创建抽象类和抽象方法。

synchronized 和 volatile 修饰符，主要用于线程的编程。





### final 修饰符

**final 变量：**

final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。

final 修饰符通常和 static 修饰符一起使用来创建类常量。



**final 方法**

父类中的 final 方法可以被子类继承，但是不能被子类重写。

声明 final 方法的主要目的是防止该方法的内容被修改。

**final 类**

final 类不能被继承，没有类能够继承 final 类的任何特性。





### final、static、abstract 之间不能同时使用的问题：

1、final 不能同时和 abstract 使用，例子：

```
abstract final void m();
```

**原因：**因为 abstract 是需要被子类继承覆盖的，否则毫无意义，而 final 作用是禁止继承的，两者相互排斥，所以不呢能 共用。

2：static 和 abstract 也是不能连用的，例子：

```
abstract static void m(){}
```

**原因：**因为 static 是类级别的不能被子类覆盖，而 abstract 需要被继承实现，两者相互矛盾。



### synchronized 修饰符

synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。



### transient 修饰符

序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。



当对象被序列化时（写入字节序列到目标文件）时，transient阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。



### volatile 修饰符

volatile 修饰的成员变量在**每次被线程访问**时，都强制从共享内存中重新**读取**该成员变量的值。而且，当成员变量**发生变化**时，会强制线程将变化值回**写到**共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。

一个 volatile 对象引用可能是 null。



volatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。

使用的场景之一，单例模式中采用DCL双锁检测（double checked locking）机制，在多线程访问的情况下，可使用volatitle修改，保证多线程下的可见性。缺点是性能有损失，因此单线程情况下不必用此修饰符。





